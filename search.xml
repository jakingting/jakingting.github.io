<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[OkHttp官方文档]]></title>
      <url>http://yoursite.com/2016/06/28/OkHttp%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h1 id="OkHttp官方文档"><a href="#OkHttp官方文档" class="headerlink" title="OkHttp官方文档"></a>OkHttp官方文档</h1><p>本文结构</p>
<ul>
<li><strong>Calls</strong></li>
<li><strong>Connections</strong></li>
<li><strong>Recipes</strong></li>
<li><strong>Interceptors</strong></li>
<li><strong>HTTPS</strong><br><a href="https://github.com/square/okhttp/wiki/Calls" target="_blank" rel="external">本文翻译来自 官方OkHttp Wiki</a></li>
</ul>
<hr>
<h2 id="一、Calls"><a href="#一、Calls" class="headerlink" title="一、Calls"></a>一、Calls</h2><p>HTTP客户端的工作是接受你的<strong>request</strong>，并产生它的<strong>response</strong>。这个在理论上是简单的，但在实践中确是很棘手。</p>
<h3 id="1-1-请求"><a href="#1-1-请求" class="headerlink" title="1.1 请求"></a>1.1 <a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Request.html" target="_blank" rel="external">请求</a></h3><p>每一个HTTP请求中都包含一个URL，一个方法（如<em>GET</em>或<em>POST</em>），和一个请求头列表（<em>headers</em>）。请求还可以含有一个请求体（body）：一个特定内容类型的数据流。</p>
<h3 id="1-2-响应"><a href="#1-2-响应" class="headerlink" title="1.2 响应"></a>1.2 <a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Response.html" target="_blank" rel="external">响应</a></h3><p>每一个HTTP响应中都包含一个状态码（如<em>200</em>代表成功，<em>404</em>代表未找​​到），一个响应头列表（<em>headers</em>）和一个可选的响应体（<em>body</em>）。</p>
<h3 id="1-3重写请求"><a href="#1-3重写请求" class="headerlink" title="1.3重写请求"></a>1.3重写请求</h3><p>当你的OkHttp发送一个HTTP请求，你在描述一个高层次的要求：“给我获取这个网址中的这些请求头。”对于正确性和效率，OkHttp发送前会重写你的请求。</p>
<p>OkHttp可以从原来的请求中添加请求头（<em>headers</em>），包括<em>Content-Length</em>, <em>Transfer-Encoding</em>, <em>User-Agent</em>, <em>Host</em>, <em>Connection</em>, 和 <em>Content-Type</em>。除非请求头已经存在压缩响应，否则它还将添加一个<em>Accept-Encoding</em>请求头。如果你有<em>cookies</em>，OkHttp还将添加一个<em>Cookie</em>请求头。</p>
<p>一些请求会有一个缓存的响应。当这个缓存的响应不是最新的，OkHttp会发送一个有条件的GET来下载更新的响应，如果它比缓存还新。它将会添加需要的请求头，如<em>IF-Modified-Since</em>和<em>If-None-Match</em>。</p>
<h3 id="1-4重写响应"><a href="#1-4重写响应" class="headerlink" title="1.4重写响应"></a>1.4重写响应</h3><p>如果使用的是透明压缩，OkHttp会丢失相应的响应头<em>Content-Encoding</em>和<em>Content-Length</em>，这是因为它们不能用于解压响应体（<em>body</em>）。</p>
<p>如果一个条件<em>GET</em>是成功的，在指示的规范下响应来自于网络和缓存的合并。</p>
<h3 id="1-5后续请求"><a href="#1-5后续请求" class="headerlink" title="1.5后续请求"></a>1.5后续请求</h3><p>当你的请求的URL已经移动，Web服务器将返回一个响应码像<em>302</em>，以表明本文档的新的URL。OkHttp将按照重定向检索的最终响应。</p>
<p>如果响应问题是一个的授权盘问，OkHttp将会要求身份验证（如果有一个已经配置好），以满足盘问。如果身份验证提供凭据，请求将会带着凭证进行重试。</p>
<h3 id="1-6请求重试"><a href="#1-6请求重试" class="headerlink" title="1.6请求重试"></a>1.6请求重试</h3><p>有时连接失败：要么是连接池已经过时和断开，或是Web服务器本身无法达成。如果有一个是可用的，OkHttp将会使用不同的路由进行请求重试。</p>
<h3 id="1-7-呼叫"><a href="#1-7-呼叫" class="headerlink" title="1.7 呼叫"></a>1.7 <a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Call.html" target="_blank" rel="external">呼叫</a></h3><p>随着重写，重定向，后续和重试，你简单的要求可能会产生很多请求和响应。OkHttp使用呼叫（<em>Call</em>）并通过许多必要的中间请求和响应来满足你请求的任务模型。通常情况，这是不是很多！如果您的网址被重定向，或者如果您故障转移到另一个IP地址，但它会欣慰的知道你的代码会继续工作。</p>
<p>通过以下两种方式进行呼叫：</p>
<ul>
<li><strong>同步</strong>：直到响应,你的线程块是可读的。</li>
<li><strong>异步</strong>：你在任何线程进行排队请求，并且当响应是可读的时候，你会在另一个线程得到<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Callback.html" target="_blank" rel="external">回调</a>。</li>
</ul>
<p>呼叫（<em>Calls</em>）可以在任何线程中取消。如果它尚未完成，它将作为失败的呼叫（<em>Calls</em>）！当呼叫（Call）被取消的时候，如果代码试图进行写请求体（<em>request body</em>）或读取响应体（<em>response body</em>）会遭受<em>IOException</em>异常。</p>
<h3 id="1-8调度"><a href="#1-8调度" class="headerlink" title="1.8调度"></a>1.8调度</h3><p>对于同步调用，你带上你自己的线程，并负责管理并发请求。并发连接过多浪费资源; 过少的危害等待时间。</p>
<p>对于异步调用，<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Dispatcher.html" target="_blank" rel="external">调度</a>实现了最大同时请求策略。您可以设置每个Web服务器最大值（默认值为5），和整体（默认为64）。</p>
<h2 id="二、Connections"><a href="#二、Connections" class="headerlink" title="二、Connections"></a>二、Connections</h2><p>虽然只提供了URL，但是OkHttp计划使用三种类型连接你的web服务器：URL, Address, 和 Route。</p>
<h3 id="2-1URLs"><a href="#2-1URLs" class="headerlink" title="2.1URLs"></a>2.1<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/HttpUrl.html" target="_blank" rel="external">URLs</a></h3><p>URLs（如<a href="https://github.com/square/okhttp）是HTTP和因特网的基础。除了是网络上通用的和分散的命名方案，他们还指定了如何访问网络资源。" target="_blank" rel="external">https://github.com/square/okhttp）是HTTP和因特网的基础。除了是网络上通用的和分散的命名方案，他们还指定了如何访问网络资源。</a></p>
<h5 id="URLs摘要："><a href="#URLs摘要：" class="headerlink" title="URLs摘要："></a>URLs摘要：</h5><ul>
<li>它们指定该呼叫(<em>Call</em>)可以被明文（<em>HTTP</em>）或加密的（<em>HTTPS</em>），但不指定用哪个加密算法。他们也不指定如何验证对方的证书（<em><a href="https://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html" target="_blank" rel="external">HostnameVerifier</a></em>）或证书可以信任（<em><a href="https://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html" target="_blank" rel="external">SSLSocketFactory</a></em>）。</li>
<li>他们不指定是否应使用特定的代理服务器或如何与该代理服务器进行身份验证。</li>
</ul>
<p>他们还具体：每个URL识别特定的路径（如 <em>/square/okhttp</em>）和查询（如  <em>?q=sharks&amp;lang=en</em>）。每个Web服务器主机的网址。</p>
<h3 id="2-2-Addresses"><a href="#2-2-Addresses" class="headerlink" title="2.2 Addresses"></a>2.2 <a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Address.html" target="_blank" rel="external">Addresses</a></h3><p>Addresses指定网络服务器（如<em>github.com</em>）和所有的静态必要的配置，以及连接到该服务器：端口号，HTTPS设置和首选的网络协议（如<em>HTTP / 2</em>或<em>SPDY</em>）。</p>
<p>共享相同地址的URL也可以共享相同的基础TCP套接字连接。共享一个连接有实实在在的性能优点：更低的延迟，更高的吞吐量（由于TCP慢启动）和保养电池。OkHttp使用的<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html" target="_blank" rel="external">ConnectionPool</a>自动重用HTTP / 1.x的连接和多样的HTTP/ 2和SPDY连接。</p>
<p>在OkHttp地址的某些字段来自URL（<em>scheme</em>, <em>hostname</em>, <em>port</em>），其余来自<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html" target="_blank" rel="external">OkHttpClient</a>。</p>
<h3 id="2-3-Routes"><a href="#2-3-Routes" class="headerlink" title="2.3 Routes"></a>2.3 <a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Route.html" target="_blank" rel="external">Routes</a></h3><p>Routes提供连接到一个网络服务器所必需的动态信息。就是尝试特定的IP地址（如由DNS查询发现），使用确切的代理服务器（如果一个特定的IP地址的<a href="https://developer.android.com/reference/java/net/ProxySelector.html" target="_blank" rel="external">ProxySelector</a>在使用中）和协商的TLS版本（HTTPS连接）。</p>
<p>可能有单个地址对应多个路由。例如，在多个数据中心托管的Web服务器，它可能会在其DNS响应产生多个IP地址。</p>
<h3 id="2-4Connections"><a href="#2-4Connections" class="headerlink" title="2.4Connections"></a>2.4<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Connection.html" target="_blank" rel="external">Connections</a></h3><p>当你使用OkHttp进行一个URL请求，下面是它的操作流程：</p>
<ol>
<li>它使用URL和配置OkHttpClient创建一个<strong>address</strong>。此地址指定我们将如何连接到网络服务器。</li>
<li>它通过地址从连接池中取回一个连接。</li>
<li>如果它没有在池中找到连接，它会选择<em>route</em>尝试。这通常意味着使一个DNS请求， 以获取服务器的IP地址。如果需要，它会选择一个的TLS版本和代理服务器。</li>
<li>如果它是一个新的route，它连接通过建立无论是直接的socket连接，socket连接使用TLS安全通道（用于HTTPS通过一个HTTP代理），或直接TLS连接。它的TLS握手是必要的。</li>
<li>它发送HTTP请求并读取响应。<br>如果有连接出现问题，OkHttp将选择另一条route，然后再试一次。当一个服务器的地址的一个子集是不可达时，这使得OkHttp能够恢复。当连接池是过时或者试图TLS版本不受支持时，这种方式是很有用的。</li>
</ol>
<p>一旦响应已经被接收到，该连接将被返回到池中，以便它可以在将来的请求中被重用。连接在池中闲置一段时间后，它会被赶出。</p>
<h2 id="三、Recipes"><a href="#三、Recipes" class="headerlink" title="三、Recipes"></a>三、Recipes</h2><p>我们已经写了一些方法，演示了如何解决OkHttp常见问题。通过阅读他们了解一切是如何正常工作的。可以自由剪切和粘贴这些例子。</p>
<h3 id="3-1同步获取"><a href="#3-1同步获取" class="headerlink" title="3.1同步获取"></a>3.1同步获取</h3><p>下载文件，打印其头部，并以字符串形式打印其响应体。</p>
<p>该<em>string()</em> 方法在响应体中是方便快捷的小型文件。但是，如果响应体是大的（大于1 MIB以上），它会在整个文件加载到内存中，所以应该避免<em>string()</em> 。在这种情况下，更倾向于将响应体作为流进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">   Headers responseHeaders = response.headers();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class="line">     System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2异步获取"><a href="#3-2异步获取" class="headerlink" title="3.2异步获取"></a>3.2异步获取</h3><p>下载一个工作线程的文件，当响应是可读的时候，获取回调（<em>Callback</em>）。当响应头已经准备好后，将产生回调（<em>Callback</em>）。读取响应体可能一直阻塞。目前OkHttp不提供异步API来接收响应体的部位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">        Headers responseHeaders = response.headers();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">          System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(response.body().string());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3访问头"><a href="#3-3访问头" class="headerlink" title="3.3访问头"></a>3.3访问头</h3><p>典型的HTTP头工作就像一个<em>Map</em>&lt;<em>String, String</em>&gt; ：每个字段都有一个值或无值。但是，一些头部(<em>headers</em>)允许多个值，比如Guava的Multimap。例如，它共同为一个HTTP响应提供多个<em>Vary</em>头。OkHttp的API，试图使这两种情况下都能舒适使用。</p>
<p>当写请求头，用<em>header(name, value)</em>来为唯一出现的<em>name</em>设置<em>value</em>。如果存在现有值，在添加新的<em>value</em>之前，他们将被移除。使用<em>addHeader(name, value)</em>来添加头部不需要移除当前存在的<em>headers</em>。</p>
<p>当读取响应头，用<em>header(name)</em>返回最后设置name的value。如果没有<em>value</em>，<em>header(name)</em>将返回null。读取所有以列表字段的值，可以使用<em>headers(name)</em>。</p>
<p>要访问所有的头部，用<em>Headers</em>类，它支持索引访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"https://api.github.com/repos/square/okhttp/issues"</span>)</span><br><span class="line">       .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Headers.java"</span>)</span><br><span class="line">       .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/json; q=0.5"</span>)</span><br><span class="line">       .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/vnd.github.v3+json"</span>)</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"Server: "</span> + response.header(<span class="string">"Server"</span>));</span><br><span class="line">   System.out.println(<span class="string">"Date: "</span> + response.header(<span class="string">"Date"</span>));</span><br><span class="line">   System.out.println(<span class="string">"Vary: "</span> + response.headers(<span class="string">"Vary"</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4Posting-a-String"><a href="#3-4Posting-a-String" class="headerlink" title="3.4Posting a String"></a>3.4Posting a String</h3><p>使用HTTP POST的请求体发送到服务。下面例子post了一个markdown文档到一个的Web服务（将markdown作为HTML）。由于整个请求体是同时在内存中，应避免使用此API发送较大（大于1 MIB）的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">      = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String postBody = <span class="string">""</span></span><br><span class="line">        + <span class="string">"Releases\n"</span></span><br><span class="line">        + <span class="string">"--------\n"</span></span><br><span class="line">        + <span class="string">"\n"</span></span><br><span class="line">        + <span class="string">" * _1.0_ May 6, 2013\n"</span></span><br><span class="line">        + <span class="string">" * _1.1_ June 15, 2013\n"</span></span><br><span class="line">        + <span class="string">" * _1.2_ August 11, 2013\n"</span>;</span><br><span class="line"></span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Post-Streaming"><a href="#3-5-Post-Streaming" class="headerlink" title="3.5 Post Streaming"></a>3.5 Post Streaming</h3><p>在这里，我们POST请求体作为<em>stream</em>。正在生成请求体的内容写入到<em>stream</em>中。下面例子<em>streams</em>直接进入 <a href="https://github.com/square/okio" target="_blank" rel="external">Okio</a>缓冲水槽。你的程序可能更喜欢使用OutputStream，你可以通过BufferedSink.outputStream（）获得 OutputStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">     = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   RequestBody requestBody = <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> MEDIA_TYPE_MARKDOWN;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       sink.writeUtf8(<span class="string">"Numbers\n"</span>);</span><br><span class="line">       sink.writeUtf8(<span class="string">"-------\n"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">997</span>; i++) &#123;</span><br><span class="line">         sink.writeUtf8(String.format(<span class="string">" * %s = %s\n"</span>, i, factor(i)));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> String <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> x = n / i;</span><br><span class="line">         <span class="keyword">if</span> (x * i == n) <span class="keyword">return</span> factor(x) + <span class="string">" × "</span> + i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Integer.toString(n);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">       .post(requestBody)</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-Posting-a-File"><a href="#3-6-Posting-a-File" class="headerlink" title="3.6 Posting a File"></a>3.6 Posting a File</h3><p>它是很容易的将文件作为请求体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">      = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"README.md"</span>);</span><br><span class="line"></span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-发布表单参数"><a href="#3-7-发布表单参数" class="headerlink" title="3.7 发布表单参数"></a>3.7 发布表单参数</h3><p>使用<em>FormBody.Builder</em>建立一个请求体，它就像一个HTML 的<form>标记。<em>Names</em> 和<em>values</em>将使用HTML兼容的表单URL编码进行编码。</form></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">       .add(<span class="string">"search"</span>, <span class="string">"Jurassic Park"</span>)</span><br><span class="line">       .build();</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"https://en.wikipedia.org/w/index.php"</span>)</span><br><span class="line">       .post(formBody)</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-发布multipart请求"><a href="#3-8-发布multipart请求" class="headerlink" title="3.8 发布multipart请求"></a>3.8 发布multipart请求</h3><p><em>MultipartBody.Builder</em>可以构建与<em>HTML</em>文件上传表单兼容的复杂的请求主体。<em>multipart</em>请求体的每一部分本身就是请求体，并且可以定义自己的头部。如果存在，这些头应该描述的部分请求体，如它的<em>Content-Disposition</em>。如果<em>Content-Length</em> 和 <em>Content-Type</em>头部可以使用，则他们会自动添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMGUR_CLIENT_ID = <span class="string">"..."</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_PNG = MediaType.parse(<span class="string">"image/png"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span></span><br><span class="line">   RequestBody requestBody = <span class="keyword">new</span> MultipartBody.Builder()</span><br><span class="line">       .setType(MultipartBody.FORM)</span><br><span class="line">       .addFormDataPart(<span class="string">"title"</span>, <span class="string">"Square Logo"</span>)</span><br><span class="line">       .addFormDataPart(<span class="string">"image"</span>, <span class="string">"logo-square.png"</span>,</span><br><span class="line">           RequestBody.create(MEDIA_TYPE_PNG, <span class="keyword">new</span> File(<span class="string">"website/static/logo-square.png"</span>)))</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .header(<span class="string">"Authorization"</span>, <span class="string">"Client-ID "</span> + IMGUR_CLIENT_ID)</span><br><span class="line">       .url(<span class="string">"https://api.imgur.com/3/image"</span>)</span><br><span class="line">       .post(requestBody)</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-通过GSON解析响应的JSON"><a href="#3-9-通过GSON解析响应的JSON" class="headerlink" title="3.9 通过GSON解析响应的JSON"></a>3.9 通过GSON解析响应的JSON</h3><p>GSON是一个JSON和Java对象之间的便利转换的API。这里，我们用它来解码从GitHub的API 响应的JSON。</p>
<p>需要注意的是<em>ResponseBody.charStream（）</em>使用的<em>Content-Type</em>响应头进行解码时，所使用的字符集，如果没有指定字符集，它默认为UTF-8 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/gists/c2a7c39532239ff261be"</span>)</span><br><span class="line">        .build();</span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</span><br><span class="line">      System.out.println(entry.getKey());</span><br><span class="line">      System.out.println(entry.getValue().content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gist</span> </span>&#123;</span><br><span class="line">    Map&lt;String, GistFile&gt; files;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GistFile</span> </span>&#123;</span><br><span class="line">    String content;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-响应缓存"><a href="#3-10-响应缓存" class="headerlink" title="3.10 响应缓存"></a>3.10 响应缓存</h3><p>要缓存响应，你需要一个缓存目录来进行读取和写入，和一个缓存的大小限制。缓存目录应该是私有的，不信任的应用程序不应该能够阅读其内容！</p>
<p>多个缓存同时访问相同的缓存目录，这是错误的。大多数应用程序应该调用一次<em>new OkHttpClient()</em>，用自己的缓存配置，在任何地方都使用相同的实例。否则，这两个缓存实例将踩到对方，破坏响应缓存，这可能使你的程序崩溃。</p>
<p>响应缓存使用HTTP头的所有配置。您可以添加请求头<em>Cache-Control: max-stale=3600</em>和OkHttp的缓存会遵循他们。你的网络服务器可以通过自己的响应头配置多长时间缓存响应，如<em>Cache-Control: max-age=9600</em>。有缓存头强制缓存的响应，强制网络响应，或强制使用条件GET验证的网络响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CacheResponse</span><span class="params">(File cacheDirectory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">   Cache cache = <span class="keyword">new</span> Cache(cacheDirectory, cacheSize);</span><br><span class="line"></span><br><span class="line">   client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">       .cache(cache)</span><br><span class="line">       .build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">   Response response1 = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response1.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response1);</span><br><span class="line"></span><br><span class="line">   String response1Body = response1.body().string();</span><br><span class="line">   System.out.println(<span class="string">"Response 1 response:          "</span> + response1);</span><br><span class="line">   System.out.println(<span class="string">"Response 1 cache response:    "</span> + response1.cacheResponse());</span><br><span class="line">   System.out.println(<span class="string">"Response 1 network response:  "</span> + response1.networkResponse());</span><br><span class="line"></span><br><span class="line">   Response response2 = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response2.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response2);</span><br><span class="line"></span><br><span class="line">   String response2Body = response2.body().string();</span><br><span class="line">   System.out.println(<span class="string">"Response 2 response:          "</span> + response2);</span><br><span class="line">   System.out.println(<span class="string">"Response 2 cache response:    "</span> + response2.cacheResponse());</span><br><span class="line">   System.out.println(<span class="string">"Response 2 network response:  "</span> + response2.networkResponse());</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"Response 2 equals Response 1? "</span> + response1Body.equals(response2Body));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>为了防止使用缓存的响应，使用<em>CacheControl.FORCE_NETWORK</em>。为了防止它使用网络，使用<em>CacheControl.FORCE_CACHE</em>。警告：如果您使用FORCE_CACHE和响应要求网络，OkHttp将会返回一个504不可满足请求的响应。</p>
<h3 id="3-11-取消Call"><a href="#3-11-取消Call" class="headerlink" title="3.11 取消Call"></a>3.11 取消Call</h3><p>使用Call.cancel（）立即停止正在进行的Call。如果一个线程目前正在写请求或读响应，它还将收到一个IOException异常。当一个Call不需要时，使用此保护网络; 例如，当用户从应用程序导航离开。同步和异步调用可以被取消。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Schedule a job to cancel the call in 1 second.</span></span><br><span class="line">    executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%.2f Canceling call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">        call.cancel();</span><br><span class="line">        System.out.printf(<span class="string">"%.2f Canceled call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Executing call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">      Response response = call.execute();</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Call was expected to fail, but completed: %s%n"</span>,</span><br><span class="line">          (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Call failed as expected: %s%n"</span>,</span><br><span class="line">          (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-12-超时"><a href="#3-12-超时" class="headerlink" title="3.12 超时"></a>3.12 超时</h3><p>当其查询无法访问时，使用超时失败的调用。网络划分可以是由于客户端连接问题，服务器可用性的问题，或之间的任何东西。OkHttp支持连接，读取和写入超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConfigureTimeouts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    System.out.println(<span class="string">"Response completed: "</span> + response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-13-每个呼叫配置"><a href="#3-13-每个呼叫配置" class="headerlink" title="3.13 每个呼叫配置"></a>3.13 每个呼叫配置</h3><p>所有的HTTP客户端配置都在OkHttpClient中包括代理设置，超时和缓存。当你需要改变单一Call的配置时，调用<em>OkHttpClient.newBuilder（）</em> 。这将返回共享相同的连接池，调度和配置与原来的客户端的建造器。在下面的例子中，我们做了500毫秒超时，另外一个3000毫秒超时请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://httpbin.org/delay/1"</span>) <span class="comment">// This URL is served with a 1 second delay.</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Copy to customize OkHttp for this request.</span></span><br><span class="line">      OkHttpClient copy = client.newBuilder()</span><br><span class="line">          .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">      Response response = copy.newCall(request).execute();</span><br><span class="line">      System.out.println(<span class="string">"Response 1 succeeded: "</span> + response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Response 1 failed: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Copy to customize OkHttp for this request.</span></span><br><span class="line">      OkHttpClient copy = client.newBuilder()</span><br><span class="line">          .readTimeout(<span class="number">3000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">      Response response = copy.newCall(request).execute();</span><br><span class="line">      System.out.println(<span class="string">"Response 2 succeeded: "</span> + response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Response 2 failed: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-14-认证处理"><a href="#3-14-认证处理" class="headerlink" title="3.14 认证处理"></a>3.14 认证处理</h3><p>OkHttp可以自动重试未经授权的请求。当响应是<em>401 Not Authorized</em>，一个<em>Authenticator</em>被要求提供凭据。实现应该建立一个包括缺少凭据的新要求。如果没有凭证可用，则返回null跳过重试。</p>
<p>使用<em>Response.challenges（）</em>获得任何认证挑战方案和领域。当完成一个基本的挑战，用<em>Credentials.basic(username, password)</em>编码请求头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Authenticate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Authenticating for response: "</span> + response);</span><br><span class="line">            System.out.println(<span class="string">"Challenges: "</span> + response.challenges());</span><br><span class="line">            String credential = Credentials.basic(<span class="string">"jesse"</span>, <span class="string">"password1"</span>);</span><br><span class="line">            <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                .header(<span class="string">"Authorization"</span>, credential)</span><br><span class="line">                .build();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://publicobject.com/secrets/hellosecret.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为了避免验证时不工作的重试，你可以返回null放弃。例如，当这些确切的凭据已经尝试,您可以跳过重试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (credential.equals(response.request().header(<span class="string">"Authorization"</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果我们已经使用这些凭据失败，不重试</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>您也可以跳过重试，当你一个应用尝试的次数超过了限制的次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (responseCount(response) &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果我们已经失败了3次，放弃。 .</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这上面的代码依赖于这个<em>responseCount（）</em>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">responseCount</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> ((response = response.priorResponse()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     result++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h2><p>拦截器是一个强大的机制，它可以监控，重写和重试Calls。下面是记录传出请求和响应传入一个简单的拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个呼叫<em>chain.proceed(request)</em>是每个拦截器的实现的重要组成部分。这个看起来简单的方法是，所有的HTTP工作情况，产生满足请求的响应。</p>
<p>拦截器可以链接。假设你有一个既压缩拦截器和拦截器校验：你需要确定数据是否被压缩，然后执行校验，或者是先校验然后再压缩。OkHttp使用列表来跟踪拦截器，为了拦截器被调用。<br><img src="http://img.blog.csdn.net/20160628191638424" alt="这里写图片描述"></p>
<h3 id="4-1-应用拦截器"><a href="#4-1-应用拦截器" class="headerlink" title="4.1 应用拦截器"></a>4.1 应用拦截器</h3><p>拦截器被注册为任一应用程序或网络拦截器。我们将使用<em>LoggingInterceptor</em>上面定义以示区别。</p>
<p>注册一个应用程序拦截器通过在<em>OkHttpClient.Builder</em>上调用<em>addInterceptor（）</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure>
<p>该URL <a href="http://www.publicobject.com/helloworld.txt重定向到https://publicobject.com/helloworld.txt，并OkHttp遵循这种自动重定向。我们的应用程序拦截器被调用一次，并且从返回的响应*chain.proceed（）*具有重定向的回应：" target="_blank" rel="external">http://www.publicobject.com/helloworld.txt重定向到https://publicobject.com/helloworld.txt，并OkHttp遵循这种自动重定向。我们的应用程序拦截器被调用一次，并且从返回的响应*chain.proceed（）*具有重定向的回应：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INFO: Sending request http://www.publicobject.com/helloworld.txt on null</span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line"></span><br><span class="line">INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms</span><br><span class="line">Server: nginx/1.4.6 (Ubuntu)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 1759</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>我们可以看到，我们被重定向是因为<em>response.request().url()</em>不同于<em>request.url（）</em> 。这两个日志语句记录两个不同的URL。</p>
<h3 id="4-2-网络拦截器"><a href="#4-2-网络拦截器" class="headerlink" title="4.2 网络拦截器"></a>4.2 网络拦截器</h3><p>注册网络拦截器相当相似。调用<em>addNetworkInterceptor（）</em>代替<em>addInterceptor（）</em> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addNetworkInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure>
<p>当我们运行这段代码，拦截器运行两次。一个是初始请求<a href="http://www.publicobject.com/helloworld.txt，另一个是用于重定向到https://publicobject.com/helloworld.txt。" target="_blank" rel="external">http://www.publicobject.com/helloworld.txt，另一个是用于重定向到https://publicobject.com/helloworld.txt。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line">Host: www.publicobject.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms</span><br><span class="line">Server: nginx/1.4.6 (Ubuntu)</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 193</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://publicobject.com/helloworld.txt</span><br><span class="line"></span><br><span class="line">INFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line">Host: publicobject.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms</span><br><span class="line">Server: nginx/1.4.6 (Ubuntu)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 1759</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>网络请求还含有更多的数据，如OkHttp加入<em>Accept-Encoding: gzip</em>头部通知支持压缩响应。网络拦截器的链具有非空的连接，它可用于询问IP地址和用于连接到网络服务器的TLS配置。</p>
<h3 id="4-3-应用程序和网络拦截之间进行选择"><a href="#4-3-应用程序和网络拦截之间进行选择" class="headerlink" title="4.3 应用程序和网络拦截之间进行选择"></a>4.3 应用程序和网络拦截之间进行选择</h3><p>每个拦截器链(<em>interceptor chain</em>)具有相对优势。</p>
<h4 id="应用拦截器"><a href="#应用拦截器" class="headerlink" title="应用拦截器"></a>应用拦截器</h4><ul>
<li>不必担心像重定向和重试的中间响应。</li>
<li>总是被调用一次，即使HTTP响应来自缓存服务。</li>
<li>观察应用程序的原意。不关心OkHttp注入的头文件，如 <em>If-None-Match</em>。</li>
<li>允许短路和不调用<em>Chain.proceed（）</em> 。</li>
<li>允许重试，并多次调用Chain.proceed（） 。<h4 id="网络拦截器"><a href="#网络拦截器" class="headerlink" title="网络拦截器"></a>网络拦截器</h4></li>
<li>能够操作像重定向和重试的中间响应。</li>
<li>在短路网络不调用的缓存的响应。</li>
<li>观察会在网络上传输的数据。</li>
<li>访问<em>Connection</em>承载请求。<h3 id="4-4重写请求"><a href="#4-4重写请求" class="headerlink" title="4.4重写请求"></a>4.4重写请求</h3>拦截器可以添加，删除或替换请求头。他们还可以转换请求体。例如，如果你连接到已知支持它的网络服务器，你可以使用应用程序拦截器添加请求体的压缩。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** This interceptor compresses the HTTP request body. Many webservers can&apos;t handle this! */</span><br><span class="line">final class GzipRequestInterceptor implements Interceptor &#123;</span><br><span class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class="line">    Request originalRequest = chain.request();</span><br><span class="line">    if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) &#123;</span><br><span class="line">      return chain.proceed(originalRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request compressedRequest = originalRequest.newBuilder()</span><br><span class="line">        .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">        .method(originalRequest.method(), gzip(originalRequest.body()))</span><br><span class="line">        .build();</span><br><span class="line">    return chain.proceed(compressedRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private RequestBody gzip(final RequestBody body) &#123;</span><br><span class="line">    return new RequestBody() &#123;</span><br><span class="line">      @Override public MediaType contentType() &#123;</span><br><span class="line">        return body.contentType();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public long contentLength() &#123;</span><br><span class="line">        return -1; // We don&apos;t know the compressed length in advance!</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</span><br><span class="line">        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));</span><br><span class="line">        body.writeTo(gzipSink);</span><br><span class="line">        gzipSink.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-重写响应"><a href="#4-5-重写响应" class="headerlink" title="4.5 重写响应"></a>4.5 重写响应</h3><p>相对应的，拦截器也可以重写响应头和转换响应体。这通常不是重写请求头，因为它可能违反了Web服务器的期望导致更危险！</p>
<p>如果你在一个棘手的情况下，并做好应对的后果，重写响应头是解决问题的有效方式。例如，您可以修复服务器的配置错误的<em>Cache-Control</em>响应头以便更好地响应缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** Dangerous interceptor that rewrites the server&apos;s cache-control header. */</span><br><span class="line">private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123;</span><br><span class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class="line">    Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">    return originalResponse.newBuilder()</span><br><span class="line">        .header(&quot;Cache-Control&quot;, &quot;max-age=60&quot;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常，此方法效果最好的时候，它补充了在Web服务器上相应的修复！</p>
<h3 id="4-6-可用性"><a href="#4-6-可用性" class="headerlink" title="4.6 可用性"></a>4.6 可用性</h3><p>OkHttp的拦截器需要OkHttp 2.2或更高。不幸的是，拦截器不能与OkUrlFactory工作，或者说建立在其上的库，包括 Retrofit ≤1.8和 Picasso≤2.4。</p>
<h2 id="五、-HTTPS"><a href="#五、-HTTPS" class="headerlink" title="五、 HTTPS"></a>五、 HTTPS</h2><p>OkHttp试图平衡两个相互竞争的担忧：</p>
<ul>
<li>连接到尽可能多的主机越好。这包括运行最新版本的先进主机<em><a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="external">boringssl</a></em>和运行旧版的日期主机<a href="https://www.openssl.org/" target="_blank" rel="external"><em>OpenSSL</em></a>。</li>
<li>安全的连接。这包括远程Web服务器证书的验证和强密码交换的数据隐私。</li>
</ul>
<p>当涉及到HTTPS服务器的连接，OkHttp需要知道提供哪些<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html" target="_blank" rel="external">TLS版本</a>和<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html" target="_blank" rel="external">密码套件</a>。如果客户端想要最大限度地连接包括过时的TLS版本和弱由设计的密码套件。客户端想要最大限度地提高安全性，应该被要求使用最新版本的TLS和实力最强的加密套件。</p>
<p>具体的安全与连接的决定是由实施<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html" target="_blank" rel="external"><em>ConnectionSpec</em></a>接口。OkHttp包括三个内置的连接规格：</p>
<ul>
<li><em>MODERN_TLS</em>是连接到现代的HTTPS服务器安全的配置。</li>
<li><em>COMPATIBLE_TLS</em>是连接到一个安全，但不是现代的-HTTPS服务器的安全配置。</li>
<li><em>CLEARTEXT</em>是用于不安全配置的http：//网址。<br>默认情况下，OkHttp将尝试<em>MODERN_TLS</em>连接，如果现代配置失败的话将退回到<em>COMPATIBLE_TLS</em>连接。</li>
</ul>
<p>在每一个规范的TLS版本和密码套件可随每个发行版而更改。例如，在OkHttp 2.2，我们下降支持响应<a href="http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html" target="_blank" rel="external">POODLE</a>攻击的SSL 3.0。而在OkHttp 2.3我们下降的支持<em><a href="http://en.wikipedia.org/wiki/RC4#Security" target="_blank" rel="external">RC4</a></em>。与桌面Web浏览器，保持最新的OkHttp是保持安全的最好办法。</p>
<p>你可以用一组自定义TLS版本和密码套件建立自己的连接规格。例如，这种配置限制为三个备受推崇的密码套件。它的缺点是，它需要的Andr​​oid 5.0+和一个类似的电流网络服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConnectionSpec spec = <span class="keyword">new</span> ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  </span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class="line">    .cipherSuites(</span><br><span class="line">          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder() </span><br><span class="line">    .connectionSpecs(Collections.singletonList(spec))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="5-1证书钉扎"><a href="#5-1证书钉扎" class="headerlink" title="5.1证书钉扎"></a>5.1证书钉扎</h3><p>默认情况下，OkHttp信任主机平台的证书颁发机构。这种策略最多的连接，但它受证书颁发机构的袭击，如<a href="http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html" target="_blank" rel="external"><em>2011 DigiNotar</em></a>的攻击。它还假定您的HTTPS服务器的证书是由证书颁发机构签署。</p>
<p>使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html" target="_blank" rel="external"><em>CertificatePinner</em></a>来限制哪些证书和证书颁发机构是可信任的。证书钉扎增强了安全性，但限制你的服务器团队的能力来更新自己的TLS证书。在没有你的服务器的TLS管理员的同意下，不要使用证书钉扎！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CertificatePinning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .certificatePinner(<span class="keyword">new</span> CertificatePinner.Builder()</span><br><span class="line">            .add(<span class="string">"publicobject.com"</span>, <span class="string">"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig="</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://publicobject.com/robots.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Certificate certificate : response.handshake().peerCertificates()) &#123;</span><br><span class="line">      System.out.println(CertificatePinner.pin(certificate));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2定制信任证书"><a href="#5-2定制信任证书" class="headerlink" title="5.2定制信任证书"></a>5.2定制信任证书</h3><p>完整的代码示例显示了如何用自己的一套替换主机平台的证书颁发机构。如上所述，在没有你的服务器的TLS管理员的同意下，不要使用自定义证书！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomTrust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());</span><br><span class="line">    client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> InputStream <span class="title">trustedCertificatesInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// Full source omitted. See sample.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SSLContext <span class="title">sslContextForTrustedCertificates</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// Full source omitted. See sample.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java类型信息与应用－－动态代理]]></title>
      <url>http://yoursite.com/2016/06/26/Java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%8D%EF%BC%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文结构</p>
<ul>
<li><strong>一、前言</strong></li>
<li><strong>二、为什么需要RTTI</strong></li>
<li><strong>三、RTTI在java中的工作原理</strong></li>
<li><strong>四、类型转化前先做检测</strong></li>
<li><strong>五、动态代理</strong></li>
<li><strong>六、动态代理的不足</strong></li>
</ul>
<hr>
<a id="more"></a>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h4 id="运行时信息使你可以在程序运行时发现和使用类型信息"><a href="#运行时信息使你可以在程序运行时发现和使用类型信息" class="headerlink" title="运行时信息使你可以在程序运行时发现和使用类型信息"></a>运行时信息使你可以在程序运行时发现和使用类型信息</h4><h4 id="Java在运行时识别对象和类的信息的方式："><a href="#Java在运行时识别对象和类的信息的方式：" class="headerlink" title="Java在运行时识别对象和类的信息的方式："></a>Java在运行时识别对象和类的信息的方式：</h4><p> 1.一种是RTTI，它假定我们在编译时已经知道了所有的类型。<br> 2.另一种是“反射“机制，它允许我们在运行时发现和使用类的信息。<br>这带来的好处是，你可以在程序运行时发现和使用类型信息</p>
<h3 id="二、为什么需要RTTI"><a href="#二、为什么需要RTTI" class="headerlink" title="二、为什么需要RTTI"></a>二、为什么需要RTTI</h3><p>以多态为例，如下图基类是Shape（泛型），而派生出来的具体类有Circle，Square和Triangle。<br><img src="http://img.blog.csdn.net/20160523231829287" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this 调用当前类的toString()方法，返回实际的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="keyword">this</span> + <span class="string">"draw()"</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"Circle"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"Square"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"Triangle"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 把Shape对象放入List&lt;Shape&gt;的数组的时候会向上转型为Shape，从而丢失了具体的类型信息</span></span><br><span class="line">    List&lt;Shape&gt; shapeList = Arrays.asList(<span class="keyword">new</span> Circle(), <span class="keyword">new</span> Square(), <span class="keyword">new</span> Triangle());</span><br><span class="line">    <span class="comment">// 从数组中取出时，这种容器，实际上所有的元素都当成Object持有，会自动将结果转型为Shape，这就是RTTI的基本的使用。</span></span><br><span class="line">    <span class="keyword">for</span>(Shape shape : shapeList)&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出以下结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Circledraw()</span><br><span class="line">Squaredraw()</span><br><span class="line">Triangledraw()</span><br></pre></td></tr></table></figure></p>
<p>RTTI在运行时识别一个对象类型，Shape对象具体执行什么的代码，由引用所指向的具体对象Circle、Square、或Triangle而决定</p>
<h4 id="三、RTTI在java中的工作原理"><a href="#三、RTTI在java中的工作原理" class="headerlink" title="三、RTTI在java中的工作原理"></a>三、RTTI在java中的工作原理</h4><p>在运行时获取类型信息是通过Class对象实现的，java通过Class对象（每个类都有一个Class对象）来执行其RTTI，而Java虚拟机通过“类加载器“的子系统，生成Class对象。<br>所有的类在第一次使用时，都会动态加载到JVM中。流程如下图：<br><img src="/images/javatype.png" alt="流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> foot=<span class="number">2</span>;</span><br><span class="line">	 <span class="keyword">static</span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"Bird coming"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Tiger</span></span>&#123;</span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> hair=(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">	 <span class="keyword">static</span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"tiger coming"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">     Class tiger=Class.forName(<span class="string">"com.jaking.RTTI.Tiger"</span>);</span><br><span class="line">     System.out.println(<span class="string">"Class forName初始化"</span>);</span><br><span class="line">     print(Tiger.hair);</span><br><span class="line">     <span class="comment">//--------------------------</span></span><br><span class="line">    Bird cat= <span class="keyword">new</span> Bird();</span><br><span class="line">    System.out.println(<span class="string">"new 初始化"</span>);</span><br><span class="line">    print(Bird.foot);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> str)</span> </span>&#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出以下结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tiger coming</span><br><span class="line">Class forName初始化</span><br><span class="line"><span class="number">57</span></span><br><span class="line">Bird coming</span><br><span class="line"><span class="keyword">new</span> 初始化</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出通过用forName()或是new构造器都会触发上述流程，</p>
<h4 id="3-2、类字面常量"><a href="#3-2、类字面常量" class="headerlink" title="3.2、类字面常量"></a>3.2、类字面常量</h4><p>java有两种获取class对象的方法</p>
<ol>
<li>Class.getName(类的全限定名);</li>
<li>FancyToy.class</li>
</ol>
<p>万物皆对象，这句话在java中体现的淋漓尽致，<br>基本类型也可以通过方法二获取Class对象，如int.class<br>而通过方法二获取Class对象在加载中会有些区别，我们先看下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> foot=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> hair=(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);<span class="comment">//runtime</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog coming"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">     Class&lt;Dog&gt; dog=Dog.class;<span class="comment">//</span></span><br><span class="line">     System.out.println(<span class="string">"类字面常量初始化"</span>);</span><br><span class="line">     print(Dog.foot);<span class="comment">//compile constant</span></span><br><span class="line">     print(Dog.hair);<span class="comment">//jiazai </span></span><br><span class="line">     ｝</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> str)</span> </span>&#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类字面常量初始化</span><br><span class="line"><span class="number">4</span></span><br><span class="line">dog coming</span><br><span class="line"><span class="number">75</span></span><br></pre></td></tr></table></figure></p>
<p>“类字面常量初始化“在“dog coming“前面打印，可以看出通过方法二获取Class对象时，不会立刻初始化，而是被延迟到了对静态方法或非常量静态域进行首次引用才开始执行。</p>
<h4 id="3-3、泛化的Class引用"><a href="#3-3、泛化的Class引用" class="headerlink" title="3.3、泛化的Class引用"></a>3.3、泛化的Class引用</h4><p>Class引用表示的是它所指向的对象的确切类型，而该对象便是Class类的一个对象。在JavaSE5中，可以通过泛型对Class引用所指向的Class对象进行限定，并且可以让编译器强制执行额外的类型检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class intCls = <span class="keyword">int</span>.class;</span><br><span class="line"><span class="comment">// 使用泛型限定Class指向的引用</span></span><br><span class="line">Class&lt;Integer&gt; genIntCls = <span class="keyword">int</span>.class;</span><br><span class="line"><span class="comment">// 没有使用泛型的Clas可以重新赋值为指向任何其他的Class对象</span></span><br><span class="line">intCls = <span class="keyword">double</span>.class;</span><br><span class="line"><span class="comment">// 下面的编译会出错</span></span><br><span class="line"><span class="comment">// genIntCls = double.class;</span></span><br></pre></td></tr></table></figure>
<p>使用通配符?放松泛型的限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; genIntCls = <span class="keyword">int</span>.class;</span><br><span class="line">genIntCls = <span class="keyword">double</span>.class;<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
<p>? extends Number将引用范围限制为Number及其子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends Number&gt; num = <span class="keyword">int</span>.class;</span><br><span class="line"><span class="comment">// num的引用范围为Number及其子类</span></span><br><span class="line">num = <span class="keyword">double</span>.class;</span><br><span class="line">num = Number.class;</span><br></pre></td></tr></table></figure></p>
<p>? super B将引用范围限制为B及其父类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Class&lt;? <span class="keyword">super</span> B&gt;  aClass=A.class;<span class="comment">//将引用</span></span><br><span class="line">		Class&lt;? <span class="keyword">super</span> B&gt;  aClass=B.class;</span><br><span class="line">		<span class="comment">//Class&lt;? super B&gt;  aClass=C.class;//编译不通过</span></span><br><span class="line">	｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<h3 id="四、类型转化前先做检测"><a href="#四、类型转化前先做检测" class="headerlink" title="四、类型转化前先做检测"></a>四、类型转化前先做检测</h3><p>有些类型如果你强制进行类型转化，如果不匹配的话就会抛出ClassCastException异常，通过关键字instanceof，告诉我们对象是不是某个特定类型的实例，再执行转化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a=<span class="keyword">new</span> B();</span><br><span class="line">		<span class="keyword">if</span> (a <span class="keyword">instanceof</span> B) &#123;</span><br><span class="line">			a=(B)a;<span class="comment">//上转型为B</span></span><br><span class="line">		&#125;</span><br><span class="line">	｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<h3 id="五、动态代理"><a href="#五、动态代理" class="headerlink" title="五、动态代理"></a>五、动态代理</h3><h4 id="5-1静态代理模式"><a href="#5-1静态代理模式" class="headerlink" title="5.1静态代理模式"></a>5.1静态代理模式</h4><p>下面是展示代理结构的简单例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//被代理类</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RealSub</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     System.out.println( <span class="string">"RealSub call doSomething()"</span> );   </span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//代理类 </span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span>  </span>&#123;</span><br><span class="line">    Subject subimpl = <span class="keyword">new</span> RealSub();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">       subimpl.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Subject sub = <span class="keyword">new</span> SubjectProxy();</span><br><span class="line">		sub.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理模式的类图<br><img src="http://img.blog.csdn.net/20160524183735104" alt="这里写图片描述"></p>
<ol>
<li><strong>抽象主题角色（Subject）</strong>：该类的主要职责是声明真实主题与代理的共同接口方法。</li>
<li><strong>真实主题角色（RealSub)</strong>：也称为委托角色或者被代理角色。定义了代理对象所代表的真实对象。</li>
<li><strong>代理主题角色（SubjectProxy)</strong>：也叫委托类、代理类。该类持有真实主题类的引用，再实现接口的方法中调用真实主题类中相应的接口方法执行，以此起到代理作用。</li>
<li><strong>客户类（ProxyClient）</strong> ：即使用代理类的类型</li>
</ol>
<p> 代理模式又分为静态代理和动态代理。静态代理是由用户创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。动态代理是在程序运行时，通过运用反射机制动态的创建而成。</p>
<h4 id="5-2、动态代理"><a href="#5-2、动态代理" class="headerlink" title="5.2、动态代理"></a>5.2、动态代理</h4><p>Java 动态代理机制的出现，使得 Java 开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。</p>
<h4 id="5-2-1、Jdk动态代理"><a href="#5-2-1、Jdk动态代理" class="headerlink" title="5.2.1、Jdk动态代理"></a>5.2.1、Jdk动态代理</h4><p> Jdk的动态代理是基于接口的。现在想要为RealSubject这个类创建一个动态代理对象，Jdk主要会做一下工作：</p>
<ol>
<li>获取RealSubject上的所有接口列表</li>
<li>确定要生成的代理类的类名，默认为：com.sun.proxy.\$ProxyN(包名与这些接口的包名相同,生成代理类的类名，格式“\$ProxyN”,其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率)；</li>
<li>根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码；</li>
<li>创建InvocationHandler实例handler,用来处理Proxy所有方法的调用；</li>
<li>Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象；</li>
<li>Jdk通过java.lang.reflect.Proxy包来支持动态代理，在Java中要创建一个代理对象，必须调用Proxy类的静态方法newProxyInstance()获取代理对象。</li>
</ol>
<p>下面为实例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaking.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象主题类B ，JDK的动态代理是基于接口的，所以一定要是interface  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubjectA</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题类B</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubjectB</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类A，即被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubjectA</span> <span class="keyword">implements</span> <span class="title">SubjectA</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"RealSubjectA request() ..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类B，即被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubjectB</span> <span class="keyword">implements</span> <span class="title">SubjectB</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"RealSubjectB doSomething() ..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态代理类，实现InvocationHandler接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	Object obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 覆盖InvocationHandler接口中的invoke()方法</span><br><span class="line">	 * </span><br><span class="line">	 * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到</span><br><span class="line">	 * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊 代码切入的扩展点了。</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> proxy</span><br><span class="line">	 *            ，表示执行这个方法的代理对象；</span><br><span class="line">	 * <span class="doctag">@param</span> method</span><br><span class="line">	 *            ，表示真实对象实际需要执行的方法（关于Method类参见Java的反射机制）；</span><br><span class="line">	 * <span class="doctag">@param</span> args</span><br><span class="line">	 *            ，表示真实对象实际执行方法时所需的参数。</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * before ：doSomething();</span><br><span class="line">		 */</span></span><br><span class="line">		Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * after : doSomething();</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 被代理类的实例</span></span><br><span class="line">		SubjectA realSubjectA = <span class="keyword">new</span> RealSubjectA();</span><br><span class="line">		<span class="comment">// loader，表示类加载器，对于不同来源（系统库或网络等）的类需要不同的类加载器来加载，这是Java安全模型的一部分。</span></span><br><span class="line">		<span class="comment">// 可以使用null来使用默认的加载器；</span></span><br><span class="line">		ClassLoader loader = realSubjectA.getClass().getClassLoader();</span><br><span class="line">		<span class="comment">// interfaces，表示接口或对象的数组，它就是前述代理对象和真实对象都必须共有的父类或者接口；</span></span><br><span class="line">		Class&lt;?&gt;[] interfaces = realSubjectA.getClass().getInterfaces();</span><br><span class="line">		<span class="comment">// handler，表示调用处理器，它必须是实现了InvocationHandler接口的对象，其作用是定义代理对象中需要执行的具体操作。</span></span><br><span class="line">		InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(realSubjectA);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获得代理的实例 A</span></span><br><span class="line">		SubjectA proxyA = (SubjectA) Proxy.newProxyInstance(loader, interfaces,</span><br><span class="line">				handler);</span><br><span class="line"></span><br><span class="line">		proxyA.request();</span><br><span class="line">		RealSubjectB realSubjectB = <span class="keyword">new</span> RealSubjectB();</span><br><span class="line">		<span class="comment">// 获得代理的实例 B</span></span><br><span class="line">		SubjectB proxyB = (SubjectB) Proxy.newProxyInstance(realSubjectB</span><br><span class="line">				.getClass().getClassLoader(), realSubjectB.getClass()</span><br><span class="line">				.getInterfaces(), <span class="keyword">new</span> DynamicProxy(realSubjectB));</span><br><span class="line"></span><br><span class="line">		proxyB.doSomething();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印生成代理类的类名</span></span><br><span class="line">		System.out.println(proxyA.getClass().getSimpleName());</span><br><span class="line">		System.out.println(proxyB.getClass().getSimpleName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行打印出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RealSubjectA <span class="title">request</span><span class="params">()</span> ...</span><br><span class="line">RealSubjectB <span class="title">doSomething</span><span class="params">()</span> ...</span><br><span class="line">$Proxy0</span><br><span class="line">$Proxy1</span></span><br></pre></td></tr></table></figure>
<p> 控制台打印出\$Proxy0，\$Proxy1可以证明\$Proxy0和\$Proxy1是JVM在运行时生成的动态代理类，这也就是动态代理的核心所在，我们不用为每个被代理类实现一个代理类，只需要实现接口InvocationHandler，并在客户端中调用静态方法Proxy.newProxyInstance( )就能获取到代理类对象</p>
<p> <strong>下图为动态代理类\$ProxyN的继承图</strong><br><img src="http://img.blog.csdn.net/20160524223126118" alt="这里写图片描述"><br> 由图可见，</p>
<ol>
<li>Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。</li>
<li>被代理的一组接口有以下特点。<br>（1）要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。<br>（2）这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。<br>（3）需被代理的所有非 public 的接口必须在同一个包中，否则代理类生成也会失败。<br>（4）接口的数目不能超过 65535，这是 JVM 设定的限制。<h3 id="六、动态代理的不足"><a href="#六、动态代理的不足" class="headerlink" title="六、动态代理的不足"></a>六、动态代理的不足</h3>动态代理的性能会比较差一些。理由很简单，因为反射地分派方法而不是采用内置的虚方法分派，可能有一些性能上的成本，但是通过动态代理可以简化大量代码，大大减低耦合度，如Spring中的AOP，Struts2中的拦截器就是使用动态代理，至于性能与便捷有时需要权衡使用。</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
